##' Climatological slicing of dates
##'
##' Given a sequence of dates, creates an object that indexes the sets
##' of dates falling into each of a series of climatological moving
##' windows.
##'
##' \code{cslice} generates indices for a set of inner and outer
##' windows.  The inner windows are contiguous and non-overlapping;
##' the outer windows overlap and are centered on the inner windows.
##' Applying an operation like the mean or the variance to the outer
##' window gives a moving-window statistic for the set of inner
##' windows.  For example, if the inner windows are 1 day long and the
##' outer windows are 30 days long, averaging over the outer windows
##' generates a daily climatology with a 30-day filter, which is
##' smoother and more robust than simply averaging over the Nth day of
##' each year.
##'
##' The windows generated by \code{cslice} are all of uniform size,
##' and there are the same number of inner and outer windows.  The
##' \code{slice} and \code{unslice} functions (q.v.) use a
##' \code{cslice} object to subset data for climatological operations.
##'
##' Typically, when people generate climatologies they either don't
##' use an inner window (e.g., when generating a monthly climatology
##' from daily data) or they use an inner window with the same
##' frequency as the data.  However, allowing the length of the inner
##' window to vary is useful for smoothing out irregularities and
##' differences in the calendar.  Using this approach to generate
##' daily climatologies with 360 inner windows for multiple different
##' datasets seamlessly accommodates model data with a 360-day
##' calendar, model data with a noleap (365-day) calendar, and real
##' world data with leap years.  Likewise, it will also handle
##' irregularly-spaced and missing timesteps.
##'
##' Caveats: the function operates on dates encoded as time elapsed
##' since an epoch (start time).  When generating climatologies from
##' multiple sources, be sure that the epochs match, or the
##' climatologies may not align with one another.  Using an inner
##' window that's shorter than the sampling frequency of the data
##' could result in some output values being based on many fewer
##' inputs than others; think carefully about window sizes and the
##' temporal structure of the data.
##' 
##' The size and number of the inner and outer windows can be
##' specified using any two of the four parameters \code{num},
##' \code{ratio}, \code{inner}, and \code{outer}.  By default,
##' \code{inner} and \code{outer} are assumed to have units of days,
##' but other units should work as long as they are consistent with
##' the value of \code{year}.
##'
##' @param time A vector of times, encoded as time elapsed since some
##' start date.
##'
##' @param num The number of windows.
##'
##' @param ratio The length of the outer window as a multiple of the
##' length of the inner window.
##'
##' @param inner The length of the inner window.
##'
##' @param outer The length of the outer window.
##'
##' @param year The length of the year.
##'
##' @param names (optional) A vector of names for the windows (e.g.,
##' names of months).
##'
##' @return An object of class 'cslice' containing lists of indices
##' associated with moving windows across multiple years and a list of
##' the parameters specifying the object.
##'
##' @seealso \code{\link{slice}}
##' 
##' @export

# add plot, print, str? methods


cslice <- function(time,
                   num = ceiling(year / inner),
                   ratio = outer / inner,
                   inner = year / num,
                   outer = inner * ratio,
                   year  = yearlength(time),
                   names = NULL
                   ){

#    if(outer < inner){ stop("outer must be >= inner")}
    ## check for:
    ## inner > outer
    ## num > year? well, no, could have subdaily.  Or diff units.
    ## all finite, positive
    
    N = length(time)
    
    span <- diff(range(time))
    cycles <- span / year
  
    cs <- list(
        time   = time,
        inner  = vector(mode="list", length=num),
        outer  = vector(mode="list", length=num),
        params = namelist(span, cycles, year, ratio, inner, outer)
        )

    class(cs) <- "cslice"
    
    names(cs$inner) <- names
    names(cs$outer) <- names

    for(i in 1:num){
        cs$inner[[i]] <- which( (time - inner*(i-1)) %% year < inner)
        cs$outer[[i]] <- which( (time - inner*(i-1/2) + outer/2 ) %% year < outer)
    }    
    return(cs)
}

## examples for cslice probably just use plot/print methods
 
# 
# ## examples
# library(ncdf4)
#  
# nc <- nc_open("test/tmax.gcm.cur.nc")
# time <- ncvar_get(nc, "time")
# time@calendar <- ncatt_get(nc, "time", "calendar")$value
# tmax <- ncvar_get(nc,"tmax")[1,1,]
# 
# 
# ## inner slice example: separate data into 12 "monthly" windows
# 
# months <- c("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec")
# monthly <- cslice(time, num=12, ratio=1, names=months)
# 
# mondata <- slice(tmax, monthly)
# montime <- slice(time, monthly)
#  
# xr <- c(0,365*5)
# yr <- range(unlist(tmax))
# col <- topo.colors(12); names(col) <- months
# plot(NA, xlim=xr, ylim=yr, xlab="time", ylab="tmax")
# for(i in months){
#     points(montime[[i]],mondata[[i]],col=col[i])
# }
# abline(h=sapply(mondata,mean),col=col)
# 
# 
# ## outer slice example: normalizing daily data based on 30-day moving
# ## window vs normalizing monthly
# 
# mnorm <- lapply(mondata, normalize)
# monanom <- unslice(mnorm, monthly)
# 
# 
# daily <- cslice(time, inner=1, outer=30)
# ddata <- slice(tmax, daily, outer=TRUE)
# 
# ndata <- lapply(ddata, normalize)
# dayanom <- unslice(ndata, daily, outer=TRUE)
# 
# doy <- rep(1:365,round(monthly$param$cycles))[1:length(tmax)]
# plot(doy, monanom, xlim=c(1,30))
# points(doy, dayanom, pch='.', col="red", cex=3)
# 
# ## Enh. Not the greatest example.  May do
# 
