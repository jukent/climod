% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/denormalize.R
\name{denormalize}
\alias{denormalize}
\title{Undo the normalization of a vector of values}
\usage{
denormalize(x, shift = 0, scale = 1, pscale = 1)
}
\arguments{
\item{x}{A normalized vector}

\item{shift}{An adjustment factor added to the data during
denormalization.  Adjusts mu or gamma, respectively, for the
"zscore" and "boxcox" normalizations.}

\item{scale}{A multiplicative adjustment factor applied to the
denormalized data.  Adjusts sigma or mu2, respectively, for the
"zscore" and "scale" normalizations.}

\item{pscale}{A multiplicative adjustment factor applied to the
exponent (lambda) when denormalizing the "boxcox" normalization.}
}
\description{
Reverses the transformation applied to a vector of values by the
function \code{normalize}, using the type and parameters of the
transformation as recorded in the vector's attributes.  See
\code{\link{normalize}} for details on the transformations.
}
\details{
The ability to undo a normalization is useful in bias correction
of climate model output.  A bias correction will adjust the values
of the climate model output to match the statistical distribution
of observational data for a historical period, and then apply the
corresponding adjustment to model output for a future period.
Often, the performance of the bias correction will be improved if
the various inputs are first normalized in some way.  This
requires the normalization to be reversed after the bias
correction has been applied.

When reversing the normalization, correction factors can be
supplied to adjust the normalization parameters to compensate for
bias.  The \code{shift} and \code{scale} arguments apply additive
and multiplicative adjustments, respectively, to the data.  The
\code{pscale} argument applies a multiplicative adjustment to the
exponent used in the boxcox normalization.

The "boxcox" transformation raises the data to an arbitrary power
(lambda).  When undoing this transformation, if lambda is
non-zero, the data is first floored at zero to avoid problems with
negative inputs.
}
\examples{

obs <- rgamma(10000, shape=5, scale=3)
cur <- rgamma(10000, shape=6, scale=2)
fut <- rgamma(10000, shape=3, scale=4)

data <- namelist(obs, cur, fut)
ndata <- lapply(data, normalize, norm="power")

dmap <- distmap(ndata$cur, ndata$obs)
ndata$bcc <- predict(dmap, ndata$cur)
ndata$bcf <- predict(dmap, ndata$fut)

par(mfrow=c(2,1))

N <- length(ndata)
mplot(lapply(ndata,density), type="l")
legend("topleft",names(ndata),lwd=1,lty=seq(N),col=seq(N))

denorm <- lapply(ndata[1:3], denormalize)
adjust <- ndata$obs@lambda / ndata$cur@lambda
denorm$bcc <- denormalize(ndata$bcc, scale=adjust)
denorm$bcf <- denormalize(ndata$bcf, scale=adjust)

N <- length(denorm)
mplot(lapply(denorm,density), type="l")
legend("topright",names(denorm),lwd=1,lty=seq(N),col=seq(N)) 

}
\seealso{
\code{\link{normalize}}
}
