% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/denormalize.R
\name{denormalize}
\alias{denormalize}
\title{Undo the normalization of a vector of values}
\usage{
denormalize(x, match = NULL, adjust = NULL)
}
\arguments{
\item{x}{A normalized vector}

\item{match}{A normalized vector whose parameters should be used to
reverse the normalization.}

\item{adjust}{A normalized vector; the parameters of \code{match}
are adjusted by the difference or ratio (as appropriate) of the
paramters of \code{adjust} and \code{x} when reversing the
normalization.}
}
\description{
Reverses the transformation applied to a vector of values by the
function \code{normalize}, using the type and parameters of the
transformation as recorded in the vector's attributes.  See
\code{\link{normalize}} for details on the transformations.
}
\details{
The ability to undo a normalization is useful in bias correction
of climate model output.  A bias correction will adjust the values
of the climate model output to match the statistical distribution
of observational data for a historical period, and then apply the
corresponding adjustment to model output for a future period.
Often, the performance of the bias correction will be improved if
the various inputs are first normalized in some way.  This
requires the normalization to be reversed after the bias
correction has been applied.

After bias-correcting current period model output, the
normalization should be reversed in a way that matches the
obervations, not the input model data.  The \code{match} argument
is used for this purpose.  Similarly, after bias-correcting future
period model output, the normalization needs to be reversed so
that the result matches the observations, adjusted by the
difference between the original current and future model outputs.
The \code{adjust} argument is used for this purpose.

The "power" transformation raises the data to an arbitrary power.
When undoing this transformation, the data is first floored at
zero to avoid problems with negative inputs.
}
\examples{

obs <- rgamma(10000, shape=5, scale=3)
cur <- rgamma(10000, shape=6, scale=2)
fut <- rgamma(10000, shape=3, scale=4)

data <- namelist(obs, cur, fut)
ndata <- lapply(data, normalize, norm="power")

dmap <- distmap(ndata$cur, ndata$obs)
ndata$bcc <- predict(dmap)
ndata$bcf <- predict(dmap,ndata$fut)

N <- length(ndata)
mplot(lapply(ndata,density), type="l")
legend("topleft",names(ndata),lwd=1,lty=seq(N),col=seq(N))

denorm <- lapply(ndata[1:3], denormalize)
denorm$bcc <- denormalize(ndata$bcc, match=ndata$obs)
denorm$bcf <- denormalize(ndata$bcf, match=ndata$obs, adjust=ndata$cur)

N <- length(denorm)
mplot(lapply(denorm,density), type="l")
legend("topright",names(denorm),lwd=1,lty=seq(N),col=seq(N)) 

}
\seealso{
\code{\link{normalize}}
}

